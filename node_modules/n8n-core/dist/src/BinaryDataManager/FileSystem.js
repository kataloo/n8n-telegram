"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDataFileSystem = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const uuid_1 = require("uuid");
const PREFIX_METAFILE = 'binarymeta';
const PREFIX_PERSISTED_METAFILE = 'persistedmeta';
class BinaryDataFileSystem {
    constructor(config) {
        this.storagePath = config.localStoragePath;
        this.binaryDataTTL = config.binaryDataTTL;
        this.persistedBinaryDataTTL = config.persistedBinaryDataTTL;
    }
    async init(startPurger = false) {
        if (startPurger) {
            setInterval(async () => {
                await this.deleteMarkedFiles();
            }, this.binaryDataTTL * 30000);
            setInterval(async () => {
                await this.deleteMarkedPersistedFiles();
            }, this.persistedBinaryDataTTL * 30000);
        }
        return fs_1.promises
            .readdir(this.storagePath)
            .catch(async () => fs_1.promises.mkdir(this.storagePath, { recursive: true }))
            .then(async () => fs_1.promises.readdir(this.getBinaryDataMetaPath()))
            .catch(async () => fs_1.promises.mkdir(this.getBinaryDataMetaPath(), { recursive: true }))
            .then(async () => fs_1.promises.readdir(this.getBinaryDataPersistMetaPath()))
            .catch(async () => fs_1.promises.mkdir(this.getBinaryDataPersistMetaPath(), { recursive: true }))
            .then(async () => this.deleteMarkedFiles())
            .then(async () => this.deleteMarkedPersistedFiles())
            .then(() => { });
    }
    async storeBinaryData(binaryBuffer, executionId) {
        const binaryDataId = this.generateFileName(executionId);
        return this.addBinaryIdToPersistMeta(executionId, binaryDataId).then(async () => this.saveToLocalStorage(binaryBuffer, binaryDataId).then(() => binaryDataId));
    }
    async retrieveBinaryDataByIdentifier(identifier) {
        return this.retrieveFromLocalStorage(identifier);
    }
    async markDataForDeletionByExecutionId(executionId) {
        const tt = new Date(new Date().getTime() + this.binaryDataTTL * 60000);
        return fs_1.promises.writeFile(path_1.default.join(this.getBinaryDataMetaPath(), `${PREFIX_METAFILE}_${executionId}_${tt.valueOf()}`), '');
    }
    async deleteMarkedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataMetaPath(), PREFIX_METAFILE);
    }
    async deleteMarkedPersistedFiles() {
        return this.deleteMarkedFilesByMeta(this.getBinaryDataPersistMetaPath(), PREFIX_PERSISTED_METAFILE);
    }
    async addBinaryIdToPersistMeta(executionId, identifier) {
        const currentTime = new Date().getTime();
        const timeAtNextHour = currentTime + 3600000 - (currentTime % 3600000);
        const timeoutTime = timeAtNextHour + this.persistedBinaryDataTTL * 60000;
        const filePath = path_1.default.join(this.getBinaryDataPersistMetaPath(), `${PREFIX_PERSISTED_METAFILE}_${executionId}_${timeoutTime}`);
        return fs_1.promises
            .readFile(filePath)
            .catch(async () => fs_1.promises.writeFile(filePath, identifier))
            .then(() => { });
    }
    async deleteMarkedFilesByMeta(metaPath, filePrefix) {
        const currentTimeValue = new Date().valueOf();
        const metaFileNames = await fs_1.promises.readdir(metaPath);
        const execsAdded = {};
        const proms = metaFileNames.reduce((prev, curr) => {
            const [prefix, executionId, ts] = curr.split('_');
            if (prefix !== filePrefix) {
                return prev;
            }
            const execTimestamp = parseInt(ts, 10);
            if (execTimestamp < currentTimeValue) {
                if (execsAdded[executionId]) {
                    prev.push(this.deleteMetaFileByPath(path_1.default.join(metaPath, curr)));
                    return prev;
                }
                execsAdded[executionId] = 1;
                prev.push(this.deleteBinaryDataByExecutionId(executionId).then(async () => this.deleteMetaFileByPath(path_1.default.join(metaPath, curr))));
            }
            return prev;
        }, [Promise.resolve()]);
        return Promise.all(proms).then(() => { });
    }
    async duplicateBinaryDataByIdentifier(binaryDataId, prefix) {
        const newBinaryDataId = this.generateFileName(prefix);
        return fs_1.promises
            .copyFile(path_1.default.join(this.storagePath, binaryDataId), path_1.default.join(this.storagePath, newBinaryDataId))
            .then(() => newBinaryDataId);
    }
    async deleteBinaryDataByExecutionId(executionId) {
        const regex = new RegExp(`${executionId}_*`);
        const filenames = await fs_1.promises.readdir(path_1.default.join(this.storagePath));
        const proms = filenames.reduce((allProms, filename) => {
            if (regex.test(filename)) {
                allProms.push(fs_1.promises.rm(path_1.default.join(this.storagePath, filename)));
            }
            return allProms;
        }, [Promise.resolve()]);
        return Promise.all(proms).then(async () => Promise.resolve());
    }
    async deleteBinaryDataByIdentifier(identifier) {
        return this.deleteFromLocalStorage(identifier);
    }
    async persistBinaryDataForExecutionId(executionId) {
        return fs_1.promises.readdir(this.getBinaryDataPersistMetaPath()).then(async (metafiles) => {
            const proms = metafiles.reduce((prev, curr) => {
                if (curr.startsWith(`${PREFIX_PERSISTED_METAFILE}_${executionId}_`)) {
                    prev.push(fs_1.promises.rm(path_1.default.join(this.getBinaryDataPersistMetaPath(), curr)));
                    return prev;
                }
                return prev;
            }, [Promise.resolve()]);
            return Promise.all(proms).then(() => { });
        });
    }
    generateFileName(prefix) {
        return `${prefix}_${(0, uuid_1.v4)()}`;
    }
    getBinaryDataMetaPath() {
        return path_1.default.join(this.storagePath, 'meta');
    }
    getBinaryDataPersistMetaPath() {
        return path_1.default.join(this.storagePath, 'persistMeta');
    }
    async deleteMetaFileByPath(metafilePath) {
        return fs_1.promises.rm(metafilePath);
    }
    async deleteFromLocalStorage(identifier) {
        return fs_1.promises.rm(path_1.default.join(this.storagePath, identifier));
    }
    async saveToLocalStorage(data, identifier) {
        await fs_1.promises.writeFile(path_1.default.join(this.storagePath, identifier), data);
    }
    async retrieveFromLocalStorage(identifier) {
        const filePath = path_1.default.join(this.storagePath, identifier);
        try {
            return await fs_1.promises.readFile(filePath);
        }
        catch (e) {
            throw new Error(`Error finding file: ${filePath}`);
        }
    }
}
exports.BinaryDataFileSystem = BinaryDataFileSystem;
//# sourceMappingURL=FileSystem.js.map