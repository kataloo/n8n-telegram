"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryDataManager = void 0;
const Constants_1 = require("../Constants");
const FileSystem_1 = require("./FileSystem");
class BinaryDataManager {
    constructor(config) {
        this.binaryDataMode = config.mode;
        this.availableModes = config.availableModes.split(',');
        this.managers = {};
    }
    static async init(config, mainManager = false) {
        if (BinaryDataManager.instance) {
            throw new Error('Binary Data Manager already initialized');
        }
        BinaryDataManager.instance = new BinaryDataManager(config);
        if (BinaryDataManager.instance.availableModes.includes('filesystem')) {
            BinaryDataManager.instance.managers.filesystem = new FileSystem_1.BinaryDataFileSystem(config);
            await BinaryDataManager.instance.managers.filesystem.init(mainManager);
        }
        return undefined;
    }
    static getInstance() {
        if (!BinaryDataManager.instance) {
            throw new Error('Binary Data Manager not initialized');
        }
        return BinaryDataManager.instance;
    }
    async storeBinaryData(binaryData, binaryBuffer, executionId) {
        const retBinaryData = binaryData;
        if (this.managers[this.binaryDataMode]) {
            return this.managers[this.binaryDataMode]
                .storeBinaryData(binaryBuffer, executionId)
                .then((filename) => {
                retBinaryData.id = this.generateBinaryId(filename);
                return retBinaryData;
            });
        }
        retBinaryData.data = binaryBuffer.toString(Constants_1.BINARY_ENCODING);
        return binaryData;
    }
    async retrieveBinaryData(binaryData) {
        if (binaryData.id) {
            return this.retrieveBinaryDataByIdentifier(binaryData.id);
        }
        return Buffer.from(binaryData.data, Constants_1.BINARY_ENCODING);
    }
    async retrieveBinaryDataByIdentifier(identifier) {
        const { mode, id } = this.splitBinaryModeFileId(identifier);
        if (this.managers[mode]) {
            return this.managers[mode].retrieveBinaryDataByIdentifier(id);
        }
        throw new Error('Storage mode used to store binary data not available');
    }
    async markDataForDeletionByExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            return this.managers[this.binaryDataMode].markDataForDeletionByExecutionId(executionId);
        }
        return Promise.resolve();
    }
    async persistBinaryDataForExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            return this.managers[this.binaryDataMode].persistBinaryDataForExecutionId(executionId);
        }
        return Promise.resolve();
    }
    async deleteBinaryDataByExecutionId(executionId) {
        if (this.managers[this.binaryDataMode]) {
            return this.managers[this.binaryDataMode].deleteBinaryDataByExecutionId(executionId);
        }
        return Promise.resolve();
    }
    async duplicateBinaryData(inputData, executionId) {
        if (inputData && this.managers[this.binaryDataMode]) {
            const returnInputData = inputData.map(async (executionDataArray) => {
                if (executionDataArray) {
                    return Promise.all(executionDataArray.map((executionData) => {
                        if (executionData.binary) {
                            return this.duplicateBinaryDataInExecData(executionData, executionId);
                        }
                        return executionData;
                    }));
                }
                return executionDataArray;
            });
            return Promise.all(returnInputData);
        }
        return Promise.resolve(inputData);
    }
    generateBinaryId(filename) {
        return `${this.binaryDataMode}:${filename}`;
    }
    splitBinaryModeFileId(fileId) {
        const [mode, id] = fileId.split(':');
        return { mode, id };
    }
    async duplicateBinaryDataInExecData(executionData, executionId) {
        const binaryManager = this.managers[this.binaryDataMode];
        if (executionData.binary) {
            const binaryDataKeys = Object.keys(executionData.binary);
            const bdPromises = binaryDataKeys.map(async (key) => {
                if (!executionData.binary) {
                    return { key, newId: undefined };
                }
                const binaryDataId = executionData.binary[key].id;
                if (!binaryDataId) {
                    return { key, newId: undefined };
                }
                return binaryManager === null || binaryManager === void 0 ? void 0 : binaryManager.duplicateBinaryDataByIdentifier(this.splitBinaryModeFileId(binaryDataId).id, executionId).then((filename) => ({
                    newId: this.generateBinaryId(filename),
                    key,
                }));
            });
            return Promise.all(bdPromises).then((b) => {
                return b.reduce((acc, curr) => {
                    if (acc.binary && curr) {
                        acc.binary[curr.key].id = curr.newId;
                    }
                    return acc;
                }, executionData);
            });
        }
        return executionData;
    }
}
exports.BinaryDataManager = BinaryDataManager;
//# sourceMappingURL=index.js.map