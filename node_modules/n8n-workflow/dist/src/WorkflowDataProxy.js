"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowDataProxy = void 0;
const luxon_1 = require("luxon");
const jmespath = __importStar(require("jmespath"));
const _1 = require(".");
class WorkflowDataProxy {
    constructor(workflow, runExecutionData, runIndex, itemIndex, activeNodeName, connectionInputData, siblingParameters, mode, defaultTimezone, additionalKeys, executeData, defaultReturnRunIndex = -1, selfData = {}) {
        this.workflow = workflow;
        this.runExecutionData = runExecutionData;
        this.defaultReturnRunIndex = defaultReturnRunIndex;
        this.runIndex = runIndex;
        this.itemIndex = itemIndex;
        this.activeNodeName = activeNodeName;
        this.connectionInputData = connectionInputData;
        this.siblingParameters = siblingParameters;
        this.mode = mode;
        this.defaultTimezone = defaultTimezone;
        this.timezone = this.workflow.settings.timezone || this.defaultTimezone;
        this.selfData = selfData;
        this.additionalKeys = additionalKeys;
        this.executeData = executeData;
        luxon_1.Settings.defaultZone = this.timezone;
    }
    nodeContextGetter(nodeName) {
        const that = this;
        const node = this.workflow.nodes[nodeName];
        return new Proxy({}, {
            ownKeys(target) {
                if (Reflect.ownKeys(target).length === 0) {
                    Object.assign(target, _1.NodeHelpers.getContext(that.runExecutionData, 'node', node));
                }
                return Reflect.ownKeys(target);
            },
            getOwnPropertyDescriptor(k) {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            get(target, name, receiver) {
                name = name.toString();
                const contextData = _1.NodeHelpers.getContext(that.runExecutionData, 'node', node);
                if (!contextData.hasOwnProperty(name)) {
                    throw new Error(`Could not find parameter "${name}" on context of node "${nodeName}"`);
                }
                return contextData[name];
            },
        });
    }
    selfGetter() {
        const that = this;
        return new Proxy({}, {
            ownKeys(target) {
                return Reflect.ownKeys(target);
            },
            get(target, name, receiver) {
                name = name.toString();
                return that.selfData[name];
            },
        });
    }
    nodeParameterGetter(nodeName) {
        const that = this;
        const node = this.workflow.nodes[nodeName];
        return new Proxy(node.parameters, {
            ownKeys(target) {
                return Reflect.ownKeys(target);
            },
            getOwnPropertyDescriptor(k) {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            get(target, name, receiver) {
                name = name.toString();
                let returnValue;
                if (name[0] === '&') {
                    const key = name.slice(1);
                    if (!that.siblingParameters.hasOwnProperty(key)) {
                        throw new Error(`Could not find sibling parameter "${key}" on node "${nodeName}"`);
                    }
                    returnValue = that.siblingParameters[key];
                }
                else {
                    if (!node.parameters.hasOwnProperty(name)) {
                        return undefined;
                    }
                    returnValue = node.parameters[name];
                }
                if (typeof returnValue === 'string' && returnValue.charAt(0) === '=') {
                    return that.workflow.expression.getParameterValue(returnValue, that.runExecutionData, that.runIndex, that.itemIndex, that.activeNodeName, that.connectionInputData, that.mode, that.timezone, that.additionalKeys, that.executeData);
                }
                return returnValue;
            },
        });
    }
    getNodeExecutionData(nodeName, shortSyntax = false, outputIndex, runIndex) {
        const that = this;
        let executionData;
        if (!shortSyntax) {
            if (that.runExecutionData === null) {
                throw new _1.ExpressionError(`Workflow did not run so do not have any execution-data.`, {
                    runIndex: that.runIndex,
                    itemIndex: that.itemIndex,
                });
            }
            if (!that.runExecutionData.resultData.runData.hasOwnProperty(nodeName)) {
                if (that.workflow.getNode(nodeName)) {
                    throw new _1.ExpressionError(`The node "${nodeName}" hasn't been executed yet, so you can't reference its output data`, {
                        runIndex: that.runIndex,
                        itemIndex: that.itemIndex,
                    });
                }
                throw new _1.ExpressionError(`No node called "${nodeName}" in this workflow`, {
                    runIndex: that.runIndex,
                    itemIndex: that.itemIndex,
                });
            }
            runIndex = runIndex === undefined ? that.defaultReturnRunIndex : runIndex;
            runIndex =
                runIndex === -1 ? that.runExecutionData.resultData.runData[nodeName].length - 1 : runIndex;
            if (that.runExecutionData.resultData.runData[nodeName].length <= runIndex) {
                throw new _1.ExpressionError(`Run ${runIndex} of node "${nodeName}" not found`, {
                    runIndex: that.runIndex,
                    itemIndex: that.itemIndex,
                });
            }
            const taskData = that.runExecutionData.resultData.runData[nodeName][runIndex].data;
            if (taskData.main === null || !taskData.main.length || taskData.main[0] === null) {
                throw new _1.ExpressionError(`No data found from "main" input.`, {
                    runIndex: that.runIndex,
                    itemIndex: that.itemIndex,
                });
            }
            if (outputIndex === undefined) {
                const nodeConnection = that.workflow.getNodeConnectionIndexes(that.activeNodeName, nodeName, 'main');
                if (nodeConnection === undefined) {
                    throw new _1.ExpressionError(`The node "${that.activeNodeName}" is not connected with node "${nodeName}" so no data can get returned from it.`, {
                        runIndex: that.runIndex,
                        itemIndex: that.itemIndex,
                    });
                }
                outputIndex = nodeConnection.sourceIndex;
            }
            if (outputIndex === undefined) {
                outputIndex = 0;
            }
            if (taskData.main.length <= outputIndex) {
                throw new _1.ExpressionError(`Node "${nodeName}" has no branch with index ${outputIndex}.`, {
                    runIndex: that.runIndex,
                    itemIndex: that.itemIndex,
                });
            }
            executionData = taskData.main[outputIndex];
        }
        else {
            executionData = that.connectionInputData;
        }
        return executionData;
    }
    nodeDataGetter(nodeName, shortSyntax = false) {
        const that = this;
        const node = this.workflow.nodes[nodeName];
        if (!node) {
            return undefined;
        }
        return new Proxy({}, {
            get(target, name, receiver) {
                name = name.toString();
                if (['binary', 'data', 'json'].includes(name)) {
                    const executionData = that.getNodeExecutionData(nodeName, shortSyntax, undefined);
                    if (executionData.length <= that.itemIndex) {
                        throw new _1.ExpressionError(`No data found for item-index: "${that.itemIndex}"`, {
                            runIndex: that.runIndex,
                            itemIndex: that.itemIndex,
                        });
                    }
                    if (['data', 'json'].includes(name)) {
                        return executionData[that.itemIndex].json;
                    }
                    if (name === 'binary') {
                        const returnData = {};
                        if (!executionData[that.itemIndex].binary) {
                            return returnData;
                        }
                        const binaryKeyData = executionData[that.itemIndex].binary;
                        for (const keyName of Object.keys(binaryKeyData)) {
                            returnData[keyName] = {};
                            const binaryData = binaryKeyData[keyName];
                            for (const propertyName in binaryData) {
                                if (propertyName === 'data') {
                                    continue;
                                }
                                returnData[keyName][propertyName] = binaryData[propertyName];
                            }
                        }
                        return returnData;
                    }
                }
                else if (name === 'context') {
                    return that.nodeContextGetter(nodeName);
                }
                else if (name === 'parameter') {
                    return that.nodeParameterGetter(nodeName);
                }
                else if (name === 'runIndex') {
                    if (that.runExecutionData === null ||
                        !that.runExecutionData.resultData.runData[nodeName]) {
                        return -1;
                    }
                    return that.runExecutionData.resultData.runData[nodeName].length - 1;
                }
                return Reflect.get(target, name, receiver);
            },
        });
    }
    envGetter() {
        const that = this;
        return new Proxy({}, {
            get(target, name, receiver) {
                if (process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE === 'true') {
                    throw new _1.ExpressionError('Environment variable access got disabled', {
                        causeDetailed: 'If you need access please contact the administrator to remove the environment variable ‘N8N_BLOCK_ENV_ACCESS_IN_NODE‘',
                        runIndex: that.runIndex,
                        itemIndex: that.itemIndex,
                        failExecution: true,
                    });
                }
                return process.env[name.toString()];
            },
        });
    }
    workflowGetter() {
        const allowedValues = ['active', 'id', 'name'];
        const that = this;
        return new Proxy({}, {
            ownKeys(target) {
                return allowedValues;
            },
            getOwnPropertyDescriptor(k) {
                return {
                    enumerable: true,
                    configurable: true,
                };
            },
            get(target, name, receiver) {
                if (!allowedValues.includes(name.toString())) {
                    throw new Error(`The key "${name.toString()}" is not supported!`);
                }
                return that.workflow[name.toString()];
            },
        });
    }
    nodeGetter() {
        const that = this;
        return new Proxy({}, {
            get(target, name, receiver) {
                return that.nodeDataGetter(name.toString());
            },
        });
    }
    getDataProxy() {
        const that = this;
        const getNodeOutput = (nodeName, branchIndex, runIndex) => {
            let executionData;
            if (nodeName === undefined) {
                executionData = that.connectionInputData;
            }
            else {
                branchIndex = branchIndex || 0;
                runIndex = runIndex === undefined ? -1 : runIndex;
                executionData = that.getNodeExecutionData(nodeName, false, branchIndex, runIndex);
            }
            return executionData;
        };
        const jmespathWrapper = (data, query) => {
            if (!Array.isArray(data) && typeof data === 'object') {
                return jmespath.search({ ...data }, query);
            }
            return jmespath.search(data, query);
        };
        const createExpressionError = (message, context) => {
            return new _1.ExpressionError(message, {
                runIndex: that.runIndex,
                itemIndex: that.itemIndex,
                failExecution: true,
                ...context,
            });
        };
        const getPairedItem = (destinationNodeName, incomingSourceData, pairedItem) => {
            let taskData;
            let sourceData = incomingSourceData;
            if (typeof pairedItem === 'number') {
                pairedItem = {
                    item: pairedItem,
                };
            }
            while (sourceData !== null && destinationNodeName !== sourceData.previousNode) {
                taskData =
                    that.runExecutionData.resultData.runData[sourceData.previousNode][(sourceData === null || sourceData === void 0 ? void 0 : sourceData.previousNodeRun) || 0];
                const previousNodeOutput = sourceData.previousNodeOutput || 0;
                if (previousNodeOutput >= taskData.data.main.length) {
                    throw createExpressionError('Can’t get data for expression', {
                        messageTemplate: 'Can’t get data for expression under ‘%%PARAMETER%%’',
                        description: `Apologies, this is an internal error. See details for more information`,
                        causeDetailed: 'Referencing a non-existent output on a node, problem with source data',
                    });
                }
                if (pairedItem.item >= taskData.data.main[previousNodeOutput].length) {
                    throw createExpressionError('Can’t get data for expression', {
                        messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                        description: `Item points to an item which does not exist`,
                        causeDetailed: `The pairedItem data points to an item ‘${pairedItem.item}‘ which does not exist on node ‘${sourceData.previousNode}‘ (output node did probably supply a wrong one)`,
                    });
                }
                const itemPreviousNode = taskData.data.main[previousNodeOutput][pairedItem.item];
                if (itemPreviousNode.pairedItem === undefined) {
                    throw createExpressionError('Can’t get data for expression', {
                        messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                        description: `To fetch the data from other nodes that this expression needs, more information is needed from the node ‘${sourceData.previousNode}’`,
                        causeDetailed: `Missing pairedItem data (node ‘${sourceData.previousNode}’ did probably not supply it)`,
                    });
                }
                if (Array.isArray(itemPreviousNode.pairedItem)) {
                    const results = itemPreviousNode.pairedItem
                        .map((item) => {
                        try {
                            const itemInput = item.input || 0;
                            if (itemInput >= taskData.source.length) {
                                throw new Error('Not found');
                            }
                            return getPairedItem(destinationNodeName, taskData.source[itemInput], item);
                        }
                        catch (error) {
                            return null;
                        }
                    })
                        .filter((result) => result !== null);
                    if (results.length !== 1) {
                        throw createExpressionError('Invalid expression', {
                            messageTemplate: 'Invalid expression under ‘%%PARAMETER%%’',
                            description: `The expression uses data in node ‘${destinationNodeName}’ but there is more than one matching item in that node`,
                        });
                    }
                    return results[0];
                }
                if (typeof itemPreviousNode.pairedItem === 'number') {
                    pairedItem = {
                        item: itemPreviousNode.pairedItem,
                    };
                }
                else {
                    pairedItem = itemPreviousNode.pairedItem;
                }
                const itemInput = pairedItem.input || 0;
                if (itemInput >= taskData.source.length) {
                    if (taskData.source.length === 0) {
                        throw createExpressionError('Invalid expression', {
                            messageTemplate: 'Invalid expression under ‘%%PARAMETER%%’',
                            description: `The expression uses data in node ‘${destinationNodeName}’ but there is no path back to it. Please check this node is connected to node ‘${that.activeNodeName}’ (there can be other nodes in between).`,
                        });
                    }
                    throw createExpressionError('Can’t get data for expression', {
                        messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                        description: `Item points to a node input which does not exist`,
                        causeDetailed: `The pairedItem data points to a node input ‘${itemInput}‘ which does not exist on node ‘${sourceData.previousNode}‘ (node did probably supply a wrong one)`,
                    });
                }
                sourceData = taskData.source[pairedItem.input || 0] || null;
            }
            if (sourceData === null) {
                throw createExpressionError('Can’t get data for expression', {
                    messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                    description: `Could not resolve, proably no pairedItem exists`,
                });
            }
            taskData =
                that.runExecutionData.resultData.runData[sourceData.previousNode][(sourceData === null || sourceData === void 0 ? void 0 : sourceData.previousNodeRun) || 0];
            const previousNodeOutput = sourceData.previousNodeOutput || 0;
            if (previousNodeOutput >= taskData.data.main.length) {
                throw createExpressionError('Can’t get data for expression', {
                    messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                    description: `Item points to a node output which does not exist`,
                    causeDetailed: `The sourceData points to a node output ‘${previousNodeOutput}‘ which does not exist on node ‘${sourceData.previousNode}‘ (output node did probably supply a wrong one)`,
                });
            }
            if (pairedItem.item >= taskData.data.main[previousNodeOutput].length) {
                throw createExpressionError('Can’t get data for expression', {
                    messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                    description: `Item points to an item which does not exist`,
                    causeDetailed: `The pairedItem data points to an item ‘${pairedItem.item}‘ which does not exist on node ‘${sourceData.previousNode}‘ (output node did probably supply a wrong one)`,
                });
            }
            return taskData.data.main[previousNodeOutput][pairedItem.item];
        };
        const base = {
            $: (nodeName) => {
                if (!nodeName) {
                    throw new _1.ExpressionError('When calling $(), please specify a node', {
                        runIndex: that.runIndex,
                        itemIndex: that.itemIndex,
                        failExecution: true,
                    });
                }
                return new Proxy({}, {
                    get(target, property, receiver) {
                        var _a;
                        if (property === 'pairedItem') {
                            return (itemIndex) => {
                                var _a, _b;
                                if (itemIndex === undefined) {
                                    itemIndex = that.itemIndex;
                                }
                                const executionData = that.connectionInputData;
                                const pairedItem = executionData[itemIndex].pairedItem;
                                if (pairedItem === undefined) {
                                    throw new _1.ExpressionError('Can’t get data for expression', {
                                        messageTemplate: `Can’t get data for expression under ‘%%PARAMETER%%’`,
                                        description: `To fetch the data from other nodes that this expression needs, more information is needed from the node ‘${that.activeNodeName}‘`,
                                        causeDetailed: `Missing pairedItem data (node ‘${that.activeNodeName}‘ did probably not supply it)`,
                                        runIndex: that.runIndex,
                                        itemIndex,
                                        failExecution: true,
                                    });
                                }
                                if (!((_a = that.executeData) === null || _a === void 0 ? void 0 : _a.source)) {
                                    throw new _1.ExpressionError('Can’t get data for expression', {
                                        messageTemplate: 'Can’t get data for expression under ‘%%PARAMETER%%’',
                                        description: `Apologies, this is an internal error. See details for more information`,
                                        causeDetailed: `Missing sourceData (probably an internal error)`,
                                        runIndex: that.runIndex,
                                        itemIndex,
                                        failExecution: true,
                                    });
                                }
                                const parentNodes = that.workflow.getParentNodes(that.activeNodeName);
                                if (!parentNodes.includes(nodeName)) {
                                    throw new _1.ExpressionError('Invalid expression', {
                                        messageTemplate: 'Invalid expression under ‘%%PARAMETER%%’',
                                        description: `The expression uses data in node ‘${nodeName}’ but there is no path back to it. Please check this node is connected to node ‘${that.activeNodeName}’ (there can be other nodes in between).`,
                                        runIndex: that.runIndex,
                                        itemIndex,
                                        failExecution: true,
                                    });
                                }
                                const sourceData = (_b = that.executeData) === null || _b === void 0 ? void 0 : _b.source.main[pairedItem.input || 0];
                                return getPairedItem(nodeName, sourceData, pairedItem);
                            };
                        }
                        if (property === 'item') {
                            return (itemIndex, branchIndex, runIndex) => {
                                if (itemIndex === undefined) {
                                    itemIndex = that.itemIndex;
                                    branchIndex = 0;
                                    runIndex = that.runIndex;
                                }
                                const executionData = getNodeOutput(nodeName, branchIndex, runIndex);
                                if (executionData[itemIndex]) {
                                    return executionData[itemIndex];
                                }
                                let errorMessage = '';
                                if (branchIndex === undefined && runIndex === undefined) {
                                    errorMessage = `
											No item found at index ${itemIndex}
											(for node "${nodeName}")`;
                                    throw new Error(errorMessage);
                                }
                                if (branchIndex === undefined) {
                                    errorMessage = `
											No item found at index ${itemIndex}
											in run ${runIndex || that.runIndex}
											(for node "${nodeName}")`;
                                    throw new Error(errorMessage);
                                }
                                if (runIndex === undefined) {
                                    errorMessage = `
											No item found at index ${itemIndex}
											of branch ${branchIndex || 0}
											(for node "${nodeName}")`;
                                    throw new Error(errorMessage);
                                }
                                errorMessage = `
										No item found at index ${itemIndex}
										of branch ${branchIndex || 0}
										in run ${runIndex || that.runIndex}
										(for node "${nodeName}")`;
                                throw new Error(errorMessage);
                            };
                        }
                        if (property === 'first') {
                            return (branchIndex, runIndex) => {
                                const executionData = getNodeOutput(nodeName, branchIndex, runIndex);
                                if (executionData[0])
                                    return executionData[0];
                                return undefined;
                            };
                        }
                        if (property === 'last') {
                            return (branchIndex, runIndex) => {
                                const executionData = getNodeOutput(nodeName, branchIndex, runIndex);
                                if (!executionData.length)
                                    return undefined;
                                if (executionData[executionData.length - 1]) {
                                    return executionData[executionData.length - 1];
                                }
                                return undefined;
                            };
                        }
                        if (property === 'all') {
                            return (branchIndex, runIndex) => getNodeOutput(nodeName, branchIndex, runIndex);
                        }
                        if (property === 'context') {
                            return that.nodeContextGetter(nodeName);
                        }
                        if (property === 'params') {
                            return (_a = that.workflow.getNode(nodeName)) === null || _a === void 0 ? void 0 : _a.parameters;
                        }
                        return Reflect.get(target, property, receiver);
                    },
                });
            },
            $input: new Proxy({}, {
                get(target, property, receiver) {
                    if (property === 'thisItem') {
                        return that.connectionInputData[that.itemIndex];
                    }
                    if (property === 'item') {
                        return (itemIndex) => {
                            if (itemIndex === undefined)
                                itemIndex = that.itemIndex;
                            const result = that.connectionInputData;
                            if (result[itemIndex]) {
                                return result[itemIndex];
                            }
                            return undefined;
                        };
                    }
                    if (property === 'first') {
                        return () => {
                            const result = that.connectionInputData;
                            if (result[0]) {
                                return result[0];
                            }
                            return undefined;
                        };
                    }
                    if (property === 'last') {
                        return () => {
                            const result = that.connectionInputData;
                            if (result.length && result[result.length - 1]) {
                                return result[result.length - 1];
                            }
                            return undefined;
                        };
                    }
                    if (property === 'all') {
                        return () => {
                            const result = that.connectionInputData;
                            if (result.length) {
                                return result;
                            }
                            return [];
                        };
                    }
                    return Reflect.get(target, property, receiver);
                },
            }),
            $thisItem: that.connectionInputData[that.itemIndex],
            $binary: {},
            $data: {},
            $env: this.envGetter(),
            $evaluateExpression: (expression, itemIndex) => {
                itemIndex = itemIndex || that.itemIndex;
                return that.workflow.expression.getParameterValue(`=${expression}`, that.runExecutionData, that.runIndex, itemIndex, that.activeNodeName, that.connectionInputData, that.mode, that.timezone, that.additionalKeys, that.executeData);
            },
            $item: (itemIndex, runIndex) => {
                const defaultReturnRunIndex = runIndex === undefined ? -1 : runIndex;
                const dataProxy = new WorkflowDataProxy(this.workflow, this.runExecutionData, this.runIndex, itemIndex, this.activeNodeName, this.connectionInputData, that.siblingParameters, that.mode, that.defaultTimezone, that.additionalKeys, that.executeData, defaultReturnRunIndex);
                return dataProxy.getDataProxy();
            },
            $items: (nodeName, outputIndex, runIndex) => {
                let executionData;
                if (nodeName === undefined) {
                    executionData = that.connectionInputData;
                }
                else {
                    outputIndex = outputIndex || 0;
                    runIndex = runIndex === undefined ? -1 : runIndex;
                    executionData = that.getNodeExecutionData(nodeName, false, outputIndex, runIndex);
                }
                return executionData;
            },
            $json: {},
            $node: this.nodeGetter(),
            $self: this.selfGetter(),
            $parameter: this.nodeParameterGetter(this.activeNodeName),
            $position: this.itemIndex,
            $runIndex: this.runIndex,
            $mode: this.mode,
            $workflow: this.workflowGetter(),
            $thisRunIndex: this.runIndex,
            $thisItemIndex: this.itemIndex,
            $now: luxon_1.DateTime.now(),
            $today: luxon_1.DateTime.now().set({ hour: 0, minute: 0, second: 0, millisecond: 0 }),
            $jmespath: jmespathWrapper,
            DateTime: luxon_1.DateTime,
            Interval: luxon_1.Interval,
            Duration: luxon_1.Duration,
            ...that.additionalKeys,
        };
        return new Proxy(base, {
            get(target, name, receiver) {
                if (['$data', '$json'].includes(name)) {
                    return that.nodeDataGetter(that.activeNodeName, true).json;
                }
                if (name === '$binary') {
                    return that.nodeDataGetter(that.activeNodeName, true).binary;
                }
                return Reflect.get(target, name, receiver);
            },
        });
    }
}
exports.WorkflowDataProxy = WorkflowDataProxy;
//# sourceMappingURL=WorkflowDataProxy.js.map